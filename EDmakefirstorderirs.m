function [irdirect,irgeom,irdiff,timingdata,outpar,existingfilename] ...
    = EDmakefirstorderirs(firstorderpathdata,fs,Rstart,difforder,envdata,...
    Sinputdata,receivers,edgedata,saveindividualfirstdiff,EDversionnumber,inpar1,inpar2)
% EDmakefirstorderirs calculates the direct sound, specular reflection, and
% first-order diffraction impulse responses.
% 
% A version 1 of this function was used up to v 0.221 of EDtoolbox
% and version 2 after that.
%
% Input parameters:
%   firstorderpathdata      Struct generated by EDfindconvexGApaths
%   fs                      Sampling frequency
%   Rstart                  The reference for time zero, in meters
%   difforder               Diffraction order
%   envdata                 Input struct; field .cair is used here
%   Sinputdata                 Struct with the fields
%   .coordinates            [nsources,3]
%   .doaddsources           [nsources,1]: 0 or 1
%   .sourceamplitudes       [nsources,1]: multiplication factor
%   receivers               Matrix, [nreceivers,3]
%   edgedata                Struct generated by EDfindedgedata
%   saveindividualfirstdiff 0 or 1
%   EDversionnumber         
%   inpar1                  This parameter is different for version 1 and
%                           version 2 of this function. 
%       v1 inpar should be showtext (optional)
%                           0 -> no text displayed. Value > 0 -> text displayed.
%       v2 of inpar should be filehandlingparameters (obligatory)
%                           filehandlingparameters is a struct which
%                           contains the field showtext.
%   inpar2                  This parameter exists only for version 2 of this function.
%                           should be EDsettingshash, which is stored in the _ir matfile. 
%
% Output parameters:
%   irdirect,irgeom,irdiff  Matrices, size [nirlength,nreceivers,nsources]
%                           (if doaddsources = 0) or [nirlength,nreceivers]
%                           (if doaddsources = 1)
%                           If the input parameter saveindividualfirstdiff
%                           = 1, then irdiff is a cell variable with one
%                           cell for each sou/rec combination: irdiff{irec,isou}.
%                           irdiff{1,1} will then contain irdiff{1,1}.irvectors =
%                           a matrix of size [nirlength,ndiffractionirs]. In addition,
%                           irdiff{1,1}.locations is a matrix of size [3,ndiffractionirs]
%                           with the [x,y,z].' for the point on the edge
%                           that causes the first arrival.
%                           Finally, irdiff{1,1}.edgenumbers is a vector of
%                           size [1,ndiffractionirs],
%   timingdata              Vector, [1,3], containing times for the direct
%                           sound, spec. reflections, and first-order diffraction
%                           component generations
%   outpar                  This parameter is different for version 1 and
%                           version 2 of this function. 
%       v1 outpar = EDinputdatahash       
%                           This is a string of characters which is
%                           uniquely representing the input data. An 
%                           existing result file with the same value of 
%                           this EDinputdatahash will be reused.
%       v2 outpar = elapsedtimemakeirs
%                           This tells how long time was used inside this
%                           function. If an existing file was reused, then
%                           elapsedtimemakeirs has a second value which tells
%                           how much time was used for the existing file.
%   existingfilename        For v2 of this function, if an existing file was
%                           found that was reused, then the reused file
%                           name is given here. If no existing file could be 
%                           reused then this variable is empty. For v1 of
%                           this function, this variable is also empty.
%   
% Uses functions EDcoordtrans2, EDwedge1st_fd, EDrecycleresultfiles from EDtoolbox
% Uses function DataHash from Matlab Central
% 
% Peter Svensson 3 Oct. 2023 (peter.svensson@ntnu.no)
%
% [[irdirect,irgeom,irdiff,timingdata,outpar,existingfilename] = EDmakefirstorderirs(firstorderpathdata,...
%    fs,Rstart,difforder,envdata,Sinputdata,receivers,edgedata,saveindividualfirstdiff,EDversionnumber,inpar1,inpar2)

% 12 Jan. 2018 First complete version. Much simplified version of the
%                           previous ESIE2maketfs. Edgehits not handled
%                           yet.
% 15 Jan. 2018 Took the direct sound and spec refl amplitude 
%              (1, 0.5, 0.25) into account)
% 17 Jan. 2018 Had forgotten the Rstart factor for the direct sound and
% specular reflection.
% 17 Jan. 2018 Took the input parameter difforder into account
% 17 Jan 2018 Added showtext as input parameter. Fixed a bug which gave the
% wrong specular reflection amplitude.
% 18 Jan 2018 Changed input parameter to the Sindata struct, to also get
% the .sourceamplitudes field. Implemented the sourceamplitudes scale
% factor.
% 28 Jan 2018 First version; modified from EDmakefirstordertfs
% 28 Feb 2018 Introducing into the EDtoolbox master
% 7 Apr 2018 Introduced the use of saveindividualfirstdiff
% 9 Apr 2018 Little bug fixed, on line 358, thanks to Ville Pulkki
% 12 Apr 2018 Little bug fixed, around line 334, thanks to Ville Pulkki
% 6 May 2018 Little bug fixed, around line 331, thanks to Ville Pulkki
% 25 Aug 2021 Introduced the new hash parameter calcfirstorderdiff.
% 29 Sep. 2023 Implemented version 2 of this function while maintaining
% compatibility with the old "version 1". v2 moves the check if an existing
% file can be reused inside this function. Also updated load and save to
% the function call form, which avoids problems with spaces in file names.
% 3 Oct. 2023 Added the EDsettingshash as input parameter.

t00 = clock;

if nargin < 11  % must be the old version
    functionversion = 1;
   showtext = 0; 
else % nargin = 11 -> can be the new or old version. Check if inpar is a struct
    if isstruct(inpar1)
		functionversion = 2;
		filehandlingparameters = inpar1;
        showtext = filehandlingparameters.showtext;
        EDsettingshash = inpar2;
	else
		functionversion = 1;
		showtext = inpar1;
	end
end

% New parameter for the hash 25 Aug. 2021: calcfirstorderdiff
calcfirstorderdiff = double(difforder > 0);

EDinputdatastruct = struct('firstorderpathdata',firstorderpathdata,'edgedata',edgedata,...
    'fs',fs,'Rstart',Rstart,'calcfirstorderdiff',calcfirstorderdiff,...
    'envdata',envdata,'Sinputdata',Sinputdata,...
    'receivers',receivers,'saveindividualfirstdiff',saveindividualfirstdiff,'EDversionnumber',EDversionnumber);
EDinputdatahash = DataHash(EDinputdatastruct);

if functionversion == 1
	outpar = EDinputdatahash;
	existingfilename = '';
elseif functionversion == 2
	%---------------------------------------------------------------
	% Sort out the file business: can an existing file be used?
	% Then copy the existing file to a new copy. Should the data be saved in a file? 

	if filehandlingparameters.suppressresultrecycling == 1
		foundmatch = 0;
		existingfilename = '';
	else
		[foundmatch,existingfilename] = ... 
			EDrecycleresultfiles(filehandlingparameters.outputdirectory,...
			'_ir',EDinputdatahash);
	end

	desiredname = [filehandlingparameters.outputdirectory,filesep,...
		filehandlingparameters.filestem,'_ir.mat'];

	if foundmatch == 1
		eval(['load(''',existingfilename,''')'])
		if ~strcmp(existingfilename,desiredname)
			copyfile(existingfilename,desiredname);
		end
		elapsedtimemakeirs_new = etime(clock,t00);
		elapsedtimemakeirs = [elapsedtimemakeirs_new elapsedtimemakeirs];
        outpar = elapsedtimemakeirs;
		return
	end
end

%----------------------------------------------------------------
% No existing file can be used

timingdata = zeros(1,3);

nreceivers = size(receivers,1);
nsources = size(Sinputdata.coordinates,1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Specular reflections

if showtext >= 2
   disp(['      Generating specular reflection components']) 
end

t00 = clock;

if firstorderpathdata.ncomponents(2) > 0

    ncomponents = size(firstorderpathdata.specrefllist(:,1),1);

    distvecs = firstorderpathdata.specreflIScoords - ...
        receivers(firstorderpathdata.specrefllist(:,2),:);

    if ncomponents == 1
       alldists = norm(distvecs);
    else
        alldists = sqrt( sum(distvecs.^2,2) );
    end

    allslotnumberfracs = (alldists-Rstart)/envdata.cair*fs+1;
    allamps = 1./alldists.*firstorderpathdata.specrefllist(:,3).*...
        Sinputdata.sourceamplitudes( firstorderpathdata.specrefllist(:,1) );
    allslotnumbers = floor(allslotnumberfracs);
    if any(allslotnumbers<1)
        error('ERROR: Rstart is set to too low a value!')
    end
    allslotnumberfracs = allslotnumberfracs - allslotnumbers;
    nirlength = max(allslotnumbers + 2);
    
    if Sinputdata.doaddsources == 1
        irgeom = zeros(nirlength,nreceivers);
    else
        irgeom = zeros(nirlength,nreceivers,nsources);
    end
    
    for ii = 1:ncomponents
        if Sinputdata.doaddsources == 0
            irgeom(allslotnumbers(ii),firstorderpathdata.specrefllist(ii,2),...
                firstorderpathdata.specrefllist(ii,1)) = ...
                  irgeom(allslotnumbers(ii),firstorderpathdata.specrefllist(ii,2),...
                  firstorderpathdata.specrefllist(ii,1)) + allamps(ii)*(1-allslotnumberfracs(ii));
            irgeom(allslotnumbers(ii)+1,firstorderpathdata.specrefllist(ii,2),...
                firstorderpathdata.specrefllist(ii,1)) = ...
                  irgeom(allslotnumbers(ii)+1,firstorderpathdata.specrefllist(ii,2),...
                  firstorderpathdata.specrefllist(ii,1)) + allamps(ii)*(allslotnumberfracs(ii));            
        else
           irgeom(allslotnumbers(ii),firstorderpathdata.specrefllist(ii,2)) = ...
                  irgeom(allslotnumbers(ii),firstorderpathdata.specrefllist(ii,2))...
                   + allamps(ii)*(1-allslotnumberfracs(ii));
            irgeom(allslotnumbers(ii)+1,firstorderpathdata.specrefllist(ii,2)) = ...
                  irgeom(allslotnumbers(ii)+1,firstorderpathdata.specrefllist(ii,2))...
                   + allamps(ii)*(allslotnumberfracs(ii));            
        end
        
    end
  
else
    nirlength = 2;
    if Sinputdata.doaddsources == 1
        irgeom = zeros(nirlength,nreceivers);
    else
        irgeom = zeros(nirlength,nreceivers,nsources);
    end    
end

timingdata(2) = etime(clock,t00);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Direct sound

if showtext >= 2
   disp(['      Generating direct sound components']) 
end
t00 = clock;

% alldists, allslotnumberfracs, allamps. allslotnumbers will be matrices 
% of size [nreceivers,nsources]

if firstorderpathdata.ncomponents(1) > 0
    ncomponents = size(firstorderpathdata.directsoundlist(:,1),1);

    distvecs = Sinputdata.coordinates(firstorderpathdata.directsoundlist(:,1),:) - ...
        receivers(firstorderpathdata.directsoundlist(:,2),:);

    if ncomponents == 1
       alldists = norm(distvecs);
    else
        alldists = sqrt( sum(distvecs.^2,2) ); 
    end
    
    allslotnumberfracs = (alldists-Rstart)/envdata.cair*fs+1;
    allamps = 1./alldists.*firstorderpathdata.directsoundlist(:,3).*...
        Sinputdata.sourceamplitudes( firstorderpathdata.directsoundlist(:,1) );
    allslotnumbers = floor(allslotnumberfracs);
    if any(allslotnumbers<1)
        error('ERROR: Rstart is set to too low a value!')
    end
    allslotnumberfracs = allslotnumberfracs - allslotnumbers;
    nirlengthdirect = max(allslotnumbers + 2);
    
    if nirlengthdirect > nirlength
        if Sinputdata.doaddsources == 1
            irgeom = [irgeom;zeros(nirlengthdirect-nirlength,nreceivers)];
        else
            irgeom = [irgeom;zeros(nirlengthdirect-nirlength,nreceivers,nsources)];
        end    
        nirlength = nirlengthdirect;
    end
    
    if Sinputdata.doaddsources == 1
        irdirect = zeros(nirlength,nreceivers);
    else
        irdirect = zeros(nirlength,nreceivers,nsources);
    end
	    
    for ii = 1:ncomponents
        if Sinputdata.doaddsources == 0
            irdirect(allslotnumbers(ii),firstorderpathdata.directsoundlist(ii,2),...
                firstorderpathdata.directsoundlist(ii,1)) = ...
                  irdirect(allslotnumbers(ii),firstorderpathdata.directsoundlist(ii,2),...
                  firstorderpathdata.directsoundlist(ii,1)) + allamps(ii)*(1-allslotnumberfracs(ii));
            irdirect(allslotnumbers(ii)+1,firstorderpathdata.directsoundlist(ii,2),...
                firstorderpathdata.directsoundlist(ii,1)) = ...
                  irdirect(allslotnumbers(ii)+1,firstorderpathdata.directsoundlist(ii,2),...
                  firstorderpathdata.directsoundlist(ii,1)) + allamps(ii)*(allslotnumberfracs(ii));            
        else
           irdirect(allslotnumbers(ii),firstorderpathdata.directsoundlist(ii,2)) = ...
                  irdirect(allslotnumbers(ii),firstorderpathdata.directsoundlist(ii,2))...
                   + allamps(ii)*(1-allslotnumberfracs(ii));
            irdirect(allslotnumbers(ii)+1,firstorderpathdata.directsoundlist(ii,2)) = ...
                  irdirect(allslotnumbers(ii)+1,firstorderpathdata.directsoundlist(ii,2))...
                   + allamps(ii)*(allslotnumberfracs(ii));            
        end
        
    end

else
    if Sinputdata.doaddsources == 1
        irdirect = zeros(nirlength,nreceivers);
    else
        irdirect = zeros(nirlength,nreceivers,nsources);
    end  
end

timingdata(1) = etime(clock,t00);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diffraction

t00 = clock;

if difforder > 0

    if showtext >= 2
        disp(['      Generating first-order diffraction components']) 
    end
    
    if saveindividualfirstdiff == 0
        if Sinputdata.doaddsources == 1
            irdiff = zeros(nirlength,nreceivers);
        else
            irdiff = zeros(nirlength,nreceivers,nsources);
        end
    else
        if Sinputdata.doaddsources == 1
            irdiff = cell(nreceivers,1);
            for ii = 1:nreceivers
               irdiff{ii,1} = struct; 
               irdiff{ii,1}.irvectors = zeros(nirlength,1); 
               irdiff{ii,1}.locations = zeros(3,1);
               irdiff{ii,1}.edgenumbers = zeros(1,1);
            end
        else
            irdiff = cell(nreceivers,nsources);
            for ii = 1:nreceivers
                for jj = 1:nsources
                    irdiff{ii,jj} = struct;
                    irdiff{ii,jj}.irvectors = zeros(nirlength,1); 
                    irdiff{ii,jj}.locations = zeros(3,1);
                    irdiff{ii,jj}.edgenumbers = zeros(1,1);
                end                
            end
        end 
        componentcounter = zeros(nreceivers,nsources);
    end
        
    iv = find(firstorderpathdata.edgeisactive);

    sou_vs_edges = sign(squeeze(sum(firstorderpathdata.diffpaths,1)));
    if size(sou_vs_edges,2) == 1
        sou_vs_edges = sou_vs_edges.';
    end
    rec_vs_edges = sign(squeeze(sum(firstorderpathdata.diffpaths,2)));
    if size(rec_vs_edges,2) == 1
        rec_vs_edges = rec_vs_edges.';
    end

    for ii = 1:length(iv)
        cylcoordS = zeros(nsources,3);
        cylcoordR = zeros(nreceivers,3);

        edgenumber = iv(ii);
        edgecoords = [edgedata.edgestartcoords(edgenumber,:);edgedata.edgeendcoords(edgenumber,:)];

        sourceandreceivercombos = squeeze(firstorderpathdata.diffpaths(:,:,edgenumber));
        iv2 = find(sourceandreceivercombos);
        [Rnumber,Snumber] = ind2sub([nreceivers,nsources],iv2);

        ivS = find(sou_vs_edges(:,edgenumber));
        ivR = find(rec_vs_edges(:,edgenumber));
        [rs,thetas,zs,rr,thetar,zr] = EDcoordtrans2(Sinputdata.coordinates(ivS,:),receivers(ivR,:),edgecoords,edgedata.edgenvecs(edgenumber,:));

        cylcoordS(ivS,:) = [rs thetas zs];
        cylcoordR(ivR,:) = [rr thetar zr];

        for jj = 1:length(iv2)
            [irnew,singularterm,singularterm,zfirst] = EDwedge1st_ir(fs,envdata.cair,edgedata.closwedangvec(edgenumber),...
                cylcoordS(Snumber(jj),1),cylcoordS(Snumber(jj),2),cylcoordS(Snumber(jj),3),...
                cylcoordR(Rnumber(jj),1),cylcoordR(Rnumber(jj),2),cylcoordR(Rnumber(jj),3),...
                edgedata.edgelengthvec(edgenumber)*[0 1],'n',Rstart,[1 1]);  

            irnew = irnew.*Sinputdata.sourceamplitudes( Snumber(jj) );
            nirlengthnew = length(irnew);

            if nirlengthnew > nirlength
                if saveindividualfirstdiff == 0
                    if Sinputdata.doaddsources == 1
                        irgeom   = [irgeom;  zeros(nirlengthnew-nirlength,nreceivers)];
                        irdirect = [irdirect;zeros(nirlengthnew-nirlength,nreceivers)];
                        irdiff = [irdiff;zeros(nirlengthnew-nirlength,nreceivers)];                    
                    else
                        irgeom   = [irgeom;  zeros(nirlengthnew-nirlength,nreceivers,nsources)];
                        irdirect = [irdirect;zeros(nirlengthnew-nirlength,nreceivers,nsources)];
                        irdiff = [irdiff;zeros(nirlengthnew-nirlength,nreceivers,nsources)];
                    end    
                else
                    if Sinputdata.doaddsources == 1
                        irgeom   = [irgeom;  zeros(nirlengthnew-nirlength,nreceivers)];
                        irdirect = [irdirect;zeros(nirlengthnew-nirlength,nreceivers)];
                        % Bug fixed 6 May 2018: before, the ncolumns in the
                        % loop was a fixed value 1, which gave errors when
                        % there was only one source.
                        for kk = 1:nreceivers
                            ncolumns = size(irdiff{kk,1}.irvectors,2);
                            irdiff{kk,1}.irvectors = [irdiff{kk,1}.irvectors;zeros(nirlengthnew-nirlength,ncolumns)]; 
                        end
                    else
                        irgeom   = [irgeom;  zeros(nirlengthnew-nirlength,nreceivers,nsources)];
                        irdirect = [irdirect;zeros(nirlengthnew-nirlength,nreceivers,nsources)];
                        for kk = 1:nreceivers
                            for mm = 1:nsources
                                ncolumns = size(irdiff{kk,mm}.irvectors,2);
                                irdiff{kk,mm}.irvectors = [irdiff{kk,mm}.irvectors;zeros(nirlengthnew-nirlength,ncolumns)];                
                            end                            
                        end
                    end                        
                end
                nirlength = nirlengthnew;                
            end    
            if saveindividualfirstdiff == 0    
                if Sinputdata.doaddsources == 1
                    irdiff(1:nirlengthnew,Rnumber(jj)) =  irdiff(1:nirlengthnew,Rnumber(jj)) + irnew;                       
                else
                    irdiff(1:nirlengthnew,Rnumber(jj),Snumber(jj)) =  irdiff(1:nirlengthnew,Rnumber(jj),Snumber(jj)) + irnew;           
                end
            else
                componentcounter(Rnumber(jj),Snumber(jj)) = componentcounter(Rnumber(jj),Snumber(jj)) + 1;
                currentcounter = componentcounter(Rnumber(jj),Snumber(jj));
                edgestart = edgedata.edgestartcoords(edgenumber,:);
                edgeend   = edgedata.edgeendcoords(edgenumber,:);                
                edgevector = edgeend - edgestart;
                xyzfirst = edgestart + zfirst*edgevector/norm(edgevector);
                
                if Sinputdata.doaddsources == 1
                    irdiff{Rnumber(jj),1}.irvectors(1:nirlengthnew,currentcounter) =  irnew;  
                    irdiff{Rnumber(jj),1}.edgenumbers(currentcounter) = edgenumber;
                    irdiff{Rnumber(jj),1}.locations(:,currentcounter) = xyzfirst(:);
                else
                    irdiff{Rnumber(jj),Snumber(jj)}.irvectors(1:nirlengthnew,currentcounter) =  irnew;           
                    irdiff{Rnumber(jj),Snumber(jj)}.edgenumbers(currentcounter) = edgenumber;
                    irdiff{Rnumber(jj),Snumber(jj)}.locations(:,currentcounter) = xyzfirst(:);
                end                
            end
        end

    end
else
   irdiff = zeros(size(irgeom));
end

timingdata(3) = etime(clock,t00);
    
if functionversion == 2
	elapsedtimemakeirs = etime(clock,t00);
    outpar = elapsedtimemakeirs;

    eval(['save(''',desiredname,''',''irdirect'',''irgeom'',''irdiff'',''timingdata'',''EDinputdatahash'',''elapsedtimemakeirs'',''EDsettingshash'');'])
end



